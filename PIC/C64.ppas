program C64;

(*
 * C64 Controller
 * Clock: 50 MHz ext. = 12.5 MHz int.
 *
 * pin layout:
 * RA0: KEYB_DATA (input)
 * RA1: KEYB_CLOCK (input/output)
 * RA2: TOD_50Hz
 * RA3: /NMI
 * RA4: /RESET
 * RA5: /MCLR
 * RA6:
 * RA7: CLKI
 * RB0-RB2: AX0-AX2 (address for COL/PA)
 * RB3-RB5: AY0-AY2 (address for ROW/PB)
 * RB6: /STROBE
 * RB7: SW_DATA
 *)
 
uses
  Keyboard;
  
const
//  TimerHi = $C2; // 50 MHz
//  TimerLo = $F7; // 50 MHz
  TimerHi = $CF; // 40 MHz
  TimerLo = $2C; // 40 MHz
//  TimerHi = $E2 // 24 MHz
//  TimerLo = $B4; // 24 MHz

var
  shiftlock_active: byte;

(******************************************************************************)
procedure Interrupt;
begin
  TMR0H := TimerHi; // interrupt every 10 ms
  TMR0L := TimerLo;

  if LATA.2 = 0 then
    LATA.2 := 1
  else
    LATA.2 := 0;

  INTCON.TMR0IF := 0;
end;
(******************************************************************************)
procedure Init;
begin
  ADCON0 := 0; // disable A/D converter
  ADCON1 := $0f;

  INTCON := %10100000; // Enable Timer0 interrupt, disable peripheral interrupts
  INTCON2 := %10000000; // disable PORTB pull-up
  INTCON3 := 0;
  PIE1 := 0;
  PIE2 := 0;
  IPR1 := 0;
  IPR2 := 0;
  RCON := 0;
  CCP1CON := 0;

  T0CON := %00000010; // Timer0: prescaler 8, 16 bit, disabled
  TMR0H := TimerHi; // interrupt every 10 ms
  TMR0L := TimerLo;

  TRISA := %00011001;
  LATA := %00000000;
  TRISB := %00000000;
  LATB := 0;

  // Init PS/2 keyboard
  InitKeyboard;
end;
(******************************************************************************)
procedure SetC64Key(key: byte; state: byte);
var
  col, row: byte;
  swaddr: byte;

begin
  col := key and 0x07;
  row := (key and 0x70) shr 4;
  swaddr := col + (row shl 3);
  LATB := swaddr or %01000000;
  if state > 0 then
    LATB.7 := 1;
  LATB.6 := 0;
  LATB.6 := 1;
end;
(******************************************************************************)
procedure MainLoop;
const
  C64SpaceKey = $74;
  C64LeftShiftKey = $17;

var
  data: byte;

begin
  shiftlock_active := 0;
  
  while true do
  begin
    KeybGetC64Key;

    if keyb_shift_lock = 1 then
    begin
      if c64key = C64LeftShiftKey then
        c64key := 255;
      if shiftlock_active = 0 then
      begin
        SetC64Key(C64LeftShiftKey, 1);
        shiftlock_active := 1;
      end;
    end
    else if shiftlock_active = 1 then
    begin
      SetC64Key(C64LeftShiftKey, 0);
      shiftlock_active := 0;
    end;

    if (key_shift = 1) and (shiftlock_active = 0) then
    begin
      if break = 1 then
        data := 0
      else
        data := 1;

      SetC64Key(C64LeftShiftKey, data);
    end;

    if c64key <> 255 then
    begin
      if break = 1 then
        data := 0
      else
        data := 1;

      SetC64Key(c64key, data);
    end;

    if restore = 1 then
    begin
      LATA.3 := 0;
      Delay_10us;
      LATA.3 := 1;
      restore := 0;
    end;

  end;
end;
(******************************************************************************)
begin
  Init;
  
  // reset CPU
  LATA.4 := 0;
  TRISA.4 := 0;
  Delay_ms(500);
  TRISA.4 := 1;

  T0CON.TMR0ON := 1; // Enable Timer0
  
  while true do
  begin
    LATA.6 := 0;
    Delay_ms(500);
    LATA.6 := 1;
    Delay_ms(500);
  end;
  
  MainLoop;
end.