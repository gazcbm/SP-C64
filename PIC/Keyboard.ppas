unit Keyboard;

(*
 * RA0: KEYB_DATA (input)
 * RA1: KEYB_CLOCK (input/output)
 *)
 
 var
   keyb_shift_lock: byte;
   restore: byte;
   c64key: byte;
   break: byte;
   key_shift: byte;

const
  ShiftCol = 1;
  ShiftRow = 3;
   
(******************************************************************************)
procedure InitKeyboard;
begin
  keyb_shift_lock := 0;
  restore := 0;
  break := 0;
  key_shift := 0;
end;
(******************************************************************************)
function KeybGetScancode(var c64key: byte): byte;
var
  i: word;

begin
  TRISA.1 := 1; // release clock line
  Delay_us(50);

  c64key := 0;

  // read start bit
  i := 0;
  while (PORTA.1 = 1) and (i < 20) do
  begin
    Delay_10us;
    inc(i);
  end;

  if PORTA.1 = 0 then
  begin
    while PORTA.1 = 0 do
      nop;

    // read data bits
    for i := 0 to 7 do
    begin
      while PORTA.1 = 1 do
        nop;
      c64key := c64key shr 1;
      c64key.7 := PORTA.0;
      while PORTA.1 = 0 do
        nop;
    end;

    // read parity bit
    while PORTA.1 = 1 do
      nop;
    while PORTA.1 = 0 do
      nop;

    // read stop bit
    while PORTA.1 = 1 do
      nop;
    while PORTA.1 = 0 do
      nop;

    Result := 1;
  end // if PORTA.1 = 0 then
  else
    Result := 0;

  LATA.1 := 0; // pull clock line to 0
  TRISA.1 := 0; // clock line = output
end; // KeybGetScancode
(******************************************************************************)
procedure KeybGetC64Key;
var
  scode: byte;
  special: byte;

begin
  c64key := 255;
  repeat
    if KeybGetScancode(scode) = 0 then
      exit;

    // special key
    if scode = $E0 then
    begin
      special := 1;
      KeybGetScancode(scode);
    end
    else
      special := 0;

    // break code
    if scode = $F0 then
    begin
      break := 1;
      KeybGetScancode(scode);
    end
    else
      break := 0;

    if special then
    begin
      case scode of
        $12: begin // RESTORE (Pause/Break)
          if break = 1 then
          begin
            KeybGetScancode(scode);
            KeybGetScancode(scode);
          end
          else begin
            restore := 1;
            exit;
          end;
        end;
        $6C: c64key := $63; // CLR/HOME
        $75: begin // UP
          c64key := $07;
          key_shift := 1;
        end;
        $6B: begin // LEFT
          c64key := $02;
          key_shift := 1;
        end;
        $72: c64key := $07; // DOWN
        $74: c64key := $02; // RIGHT
      end;
    end
    else begin
      case scode of
        $1C: c64key := $12; // A
        $32: c64key := $34; // B
        $21: c64key := $24; // C
        $23: c64key := $22; // D
        $24: c64key := $16; // E
        $2B: c64key := $25; // F
        $34: c64key := $32; // G
        $33: c64key := $35; // H
        $43: c64key := $41; // I
        $3B: c64key := $42; // J
        $42: c64key := $45; // K
        $4B: c64key := $53; // L
        $3A: c64key := $44; // M
        $31: c64key := $47; // N
        $44: c64key := $46; // O
        $4D: c64key := $51; // P
        $15: c64key := $76; // Q
        $2D: c64key := $21; // R
        $1B: c64key := $15; // S
        $2C: c64key := $26; // T
        $3C: c64key := $36; // U
        $2A: c64key := $37; // V
        $1D: c64key := $11; // W
        $22: c64key := $27; // X
        $1A: c64key := $31; // Y
        $35: c64key := $14; // Z
        $45: c64key := $43; // 0
        $16: c64key := $70; // 1
        $1E: c64key := $73; // 2
        $26: c64key := $10; // 3
        $25: c64key := $13; // 4
        $2E: c64key := $20; // 5
        $36: c64key := $23; // 6
        $3D: c64key := $30; // 7
        $3E: c64key := $33; // 8
        $46: c64key := $40; // 9
        $4E: c64key := $53; // -
        $55: c64key := $65; // =
        $66: c64key := $00; // DEL (Backspace)
        $0E: c64key := $71; // <-
        $5A: c64key := $01; // RETURN
        $76: c64key := $77; // RUN STOP (Escape)
        $54: c64key := $56; // @
        $5B: c64key := $61; // *
        $4C: c64key := $55; // [ :
        $52: c64key := $62; // ] ;
        $42: c64key := $57; // ,
        $49: c64key := $54; // .
        $4A: c64key := $67; // /

        $05: c64key := $04; // F1
        $06: begin // F2
          c64key := $04;
          key_shift := 1;
        end;
        $04: c64key := $05; // F3
        $0C: begin // F4
          c64key := $05;
          key_shift := 1;
        end;
        $03: c64key := $06; // F5
        $0B: begin // F6
          c64key := $06;
          key_shift := 1;
        end;
        $38: c64key := $03; // F7
        $0A: begin // F8
          c64key := $03;
          key_shift := 1;
        end;
        $11: c64key := $75; // C= (ALT)
        $01: c64key := $60; // £ (F9)
        $09: c64key := $50; // + (F10)
        $29: c64key := $74; // SPACE

        $12: c64key := $17; // left shift
        $59: c64key := $64; // right shift
        $14, $0D: c64key := $72; // CTRL (CTRL left, TAB)
        $00: c64key := $66; // ARROW UP (# on PS2 keyboard)
        $58: begin
          if break = 0 then
            keyb_shift_lock := 1 - keyb_shift_lock;
        end;
      end;
    end;
  until c64key <> 255;
end;
(******************************************************************************)
end.